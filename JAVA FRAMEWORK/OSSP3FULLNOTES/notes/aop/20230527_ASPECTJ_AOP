spring aop + aspject aop when these 2 are integrated, what is the feature outcome results of these 2 integrations

1. joinpoint
Spring Aop : Method
Aspect Aop : constructors, methods, initializing blocks, static blocks, finalize etc
Spring Aop + AspectJ = only the Method

2. pointcut
There are 2 types of pointcuts are there
1. static  = in static pointcut we specify fixed list of joinpoints on whom we want to advice the aspect 
2. dynamic = in dynamic pointcut, along with joinpoints we bind an condition that gets evaluated dynamically at runtime to decide whether the joinpoint should be adviced or not

3. weaving
The process we follow in advicing the aspect on to the target class to build proxy is called "Weaving"
There are #2 types of weaving are there
3.1. Compile-Time Weaving
3.2. Runtime Weaving

3.1. Compile-Time weaving
The proxy class is being generated by combining the target class + aspect logic during the time of compiling the application itself. The AOP vendor provides Weaving Compiler Tool, that should be used for generating the proxy. upon compiling the Target and Aspect classes with java compiler, we need to pass the bytecode of these 2 classes as an input to Weaving Compiler to generate proxy class.
	
Since the proxy is created during compile-time, it is called Compile-Time Weaving

There are few advantages and dis-advantages with this approach:
dis-advantages:
1. since we need to compile the code twice, it kills the developers time in developing the application, because for each change in the application, to get it reflected we need to compile it twice
2. there is always a chance where we might compile the code with java compiler and might forget to compile with weaving-compiler which leads to usage of old proxy that is previously generated, that would make the developer go in loops in debugging the code with old instance

advantage:
1. since the proxies are generated during compile-time, the performance of the application would be good while executing

2. Runtime weaving
The AOP vendor provides an Runtime Weaving engine, that sits as an object within the jvm itself. So whenever a class needs an object of another class, instead of creating the object directly, it needs to goto Runtime Weaving engine requesting the object.
	
The runtime weaving engine takes care of combining the aspect + target class and generates the proxy at runtime within the jvm memory and creates the object of it and returns.
	
since the proxy is generated at runtime, it is called runtime weaving compiler. All the dis-advantages with compile-time weaving has been resolved. but the only problem is proxy generation takes time and hence might see a performance issue.
	





























	


























