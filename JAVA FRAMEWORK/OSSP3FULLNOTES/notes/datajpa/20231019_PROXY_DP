Spring datajpa works based on Runtime proxy generation capabilities which means it purely relies on proxy design pattern in eliminating the dao layer in an application. So let us first explore what is an proxy pattern and why do we need to use it?
	
Proxy design pattern
---------------------
A Proxy class is an surrogate or a substitute of the original class. A proxy always serves the functionality that is provided by the original and always looks same as original itself. Upon invoking an proxy, it internally talks to the original class and captures the output returned by original class and returns to the client/callee.
	
Then the immediate question	that pops up is, why do we need proxy when it is also providing the same functionality of the original?
Proxy classes will not tamper or alter the output that is being generated by the original class, rather they enhance/enrich or customize the way we interact with original class in serving the functionality.

Let us understand enchancing/encriching or customizing the way we interact with original class in serving the output by taking an usecase.
	
We have an cloud storage application that stores images & videos and allows the different types of clients to browse and stream them over the network.
The clients can be either
1. mobile clients which are connected to an wifi or mobile data network
2. or an standalone desktop application based clients that most of the time connects to an broadband network
	
For these clients to allow them to browse/download, upload the images onto the cloud storage application we need an api or a class that supports in serving the functionality. That is where ImageService is being used as below.	
	
class ImageService {
	byte[] getImage(String imageName) {}
	long uploadImage(byte[] imageBytes, String imageName, String mimeType) {}
}	

When the mobile clients are connected to an mobile data network, browsing the images or streaming the videos over the network could result in severe performance or slowness and might hinder the enduser experience. So to enrich the user experience in interacting and browsing the content (images/videos) quickly we need to apply size reduction technics like reducing the original sizes of the images or reducing the quality of the images/videos or sometimes both and distributing it to the client.
	
since the size of the content has been reduced, those will be downloaded quite faster and renders in the client application quickly. This reduction capability should be applied only when the client is connected to an mobile data network, so inorder to implement this the client has to send additional input along with imageName stating the quality of the image.
	
class ImageService {
	byte[] getImage(String imageName, String quality) {}
	long uploadImage(byte[] imageBytes, String imageName, String mimeType) {}
}	
here the quality can take #4 possible values as "low", "medium", "high" and original and based the quality the reduction technic should be applied and dispatches to the client.
	
	
class ImageService {
	byte[] getImage(String imageName, String quality) {
		
		// pick the original image from the server storage
		
		if(quality.equals("low") || quality.equals("medium") || quality.equals("high")) {
			// apply reduction technics in reducing the size of the image
		}
		return: dispatch the final image to the client
	}
	long uploadImage(byte[] imageBytes, String imageName, String mimeType) {}
}		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


























