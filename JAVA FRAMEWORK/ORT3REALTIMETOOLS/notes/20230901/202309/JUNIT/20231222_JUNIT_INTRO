JUnit
-----
Testing is the process of verifying the code with pre-defined inputs (test fixtures) and check whether the output produced is matching with the expected output or not is called "testing".
	
Unit testing / test automation:	
1. is the code is ready for testing or not
2. in agile development the application is being developed in sprints, which are spanning between 1-3 weeks. Within the sprint duration the code should be developed, testing and delivered. The only way to accomplish this is having stringent test-automation in place. one of the key ways to achieve this fast-paced delivery is adopting
	2.1 unit test automation
	2.2 integration-tests
	
	
JUnit = unit testing automation framework, that is used for testing the actual code to verify whether it is working properly or not.
	
Why do we need a framework for unit test automation, what kind of boiler-plate logic we write while working on test automation?
Let us understand what kind of boiler-plate logic do we write while implementing unit testing automation by writing them without using JUnit.
	
Goals of unit testing implementation:
#1 each test that is conducted should produce the output marking the test as passed/failed

class Calculator {
	public int add(int a, int b) {
		return a + b;
	}
}	

class DateUtils {
	public int diffInDays(LocalDate fromDate, LocalDate toDate) {
		
	}
}

To test it we need run/execute the Calculator class with pre-defined set of inputs and verify the output produced is right or wrong. 
	

class AppTest {
	public static void main(String[] args) {
		Calculator calculator = new Calculator();
		int sum = calculator.add(10, 20);
		sop(sum);
		
		
		DateUtils dateUtils = new DateUtils();
		int days = dateUtils.diffInDays(LocalDate.of(2023,12,23), LocalDate.of(2023,12,25));
		sop(days);
	}
}	

In the above code we are writing test logic in testing various different classes of our application, and it is producing the output of executing the original classes. So the developer upon executing the test logic "AppTest", he/she has to spend lot of time in verifying the output produced by the test logic is passed/failed, which takes significant amount of time and the testing code we have written seems to be of little help.
	
Instead always the test code should not	produce the output of executing the original code, rather it should mark the test we have conducted is passed/failed. Precisely we are more into knowing the failures than success.
	
so always the testcode we are writing should be able to compare the produced output with the expected output and should report the test as passed/failed as below.
	
	
class AppTest {
	public static void main(String[] args) {
		Calculator calculator = new Calcualtor();
		int sum = calculator.add(10, 20);
		if(sum == 30) {
			sop(".")
		}else {
			sop("f");
		}		
	}
}	

#2. 
There are multiple classes in our application that needs to be tested by writing the test logic as below

class Calculator {
	int add(int a, int b) { return a+b; }
	int substract(int a, int b) { return b-a; }
}

class Circle {
	float area(int r) {
		return 3.14 * (r * r);
	}
	float perimeter(int r) {
		return 2 * 3.14 * r;
	}
}

class AppTest {
	public static void main(String[] args) {
		Calculator calculator = new Calculator();
		int a = 10;
		int b = 20;
		int expectedSum = 30;
		
		try {
			int actualSum = calculator.add(a, b);
			if(expectedSum == actualSum) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
		
		try {
			int expectedSubs = 10;
			int actualSubs = calculator.substract(a, b);
			if(expectedSubs == actualSubs) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
		
		Circle circle =new Circle();
		int r = 2;
		float expectedArea = 12.56;
		
		try {
			float actualArea = circle.area(r);
			if(expectedArea == actualArea) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
		
		try {
			float expectedPerimeter = 12.56;
			float actualPerimeter = circle.perimeter(r);
			if(expectedPerimeter == actualPerimeter) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
	}
}

Here we are writing test logic in testing multiple methods of multiple classes in one single test class, that makes it quite cumbersome and complex to understand and maintain the test logic. So break down the test logic into multiple test classes.
	
	
Per each class to be tested, write an Test class separately, in which write the logic for testing all the methods of the original class in it.
	
package pkg1;	
class Calculator {
	int add(int a, int b) { return a+b; }
	int substract(int a, int b) { return b-a; }
}

package pkg2;
class Circle {
	float area(int r) {
		return 3.14 * (r * r);
	}
	float perimeter(int r) {
		return 2 * 3.14 * r;
	}
}	

here we have #2 classes, so write #2 test classes, while writing the test classes follow the naming convention as ClassNameTest so that it would be easy to identify which classes has the relevant test logic of a class. In addition write the Test class within the same package of original class, so that we have maximum accessibility of the original class.
	
1. standard naming convention in writing the Test class name	
2. write the test class within the same package of original class
3. The actual sourcecode should be separated from testcode and always exclude shipping/packaging the unittest code aspart of your application packaging.
	
	
The unit test code will be executed only within the lower environments, like while promotiing the code from dev to test environment. while moving/promoting the code into the higher environments, the unit test code will not be executed (like stage, uat, prod etc), so it is not required to package the unittest code aspart of our application packaging (jar, war, ear etc)
	
so if we write our original code and testcode in src/ directory

project (dir)
|-src
	|-originalcode
	|-testcode
|-bin

when we compile all the .class files will be generated into bin/ directory, so how do we differentiate which .class files are original classes and which are test .class files and exclude them from packaging
	
so it is recommended to have #2 different directories for holding their sourcecode and class files as shown below
	
project (dir)
|-src
|-testsrc CaculatorTest 
|-bin
|-testbin

compile the sourcecode in src/ directory and place the .class files inside the bin/ directory. while compiling the testsrc directory set the classpath to the bin/ directory and place the generated .class files into testbin/ directory.
now while executing the testcode that is in testbin directory, set the classpath to both bin/ and testbin/
while packaging the application into (jar, war, ear) only include the contents of bin/ directory

package pkg1;
public class CalculatorTest {
	public static void main(String[] args) {
		Calculator calculator = new Calculator();
		int a = 10;
		int b = 20;
		int expectedSum = 30;
		
		try {
			int actualSum = calculator.add(a, b);
			if(expectedSum == actualSum) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
		
		try {
			int expectedSubs = 10;
			int actualSubs = calculator.substract(a, b);
			if(expectedSubs == actualSubs) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
	}
}
	

package pkg2;
public class CircleTest {
	public static void main(String[] args) {
		Circle circle =new Circle();
		int r = 2;
		float expectedArea = 12.56;
		
		try {
			float actualArea = circle.area(r);
			if(expectedArea == actualArea) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
		
		try {
			float expectedPerimeter = 12.56;
			float actualPerimeter = circle.perimeter(r);
			if(expectedPerimeter == actualPerimeter) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
	}
}
	
In the above code, even though we have achieved a level of readability, still within the individual class level, it is difficult to identify which piece of code is written for testing what method of the original class and still seems to be complex and difficult to maintain.
	
so instead of writing the testcode in testing all the methods of original class in one method, break down the testlogic into individual methods per each test we are conducting, which are called testcase methods.
	
There are rules to be followed in writing the test methods:
1. the testmethod need not be public, we can write with default access modifier.
2. the testmehtod always reports a success/failure, it will not produce any returnValue. so the returnType of the testmethod should be always void
3. the testmethod should be written with naming convention started with "test" followed by original methodname appended with testcase we are conducting for eg..
	if we are writing the test logic for add(int a, int b)  of Calculator class, the test method name should be
	void testAddWithPositiveNumbers() {}
  void testAddWithNegativeNumbers() {}
  void testAddWithPositiveAndNegativeNumbers() {}
  void testAddWithZeros() {}
by looking at the method names we can easily identify what method of the original class we are testing and what test we are conducting.
	
4. the testMethods performs testing the original code with fixed-set of inputs, so always the parameters for the test method will be zero arguments.
	
class CalculatorTest {
	void testAddWithPositiveNumbers() {
		Calculator calculator = new Calculator();
		int a = 10;
		int b = 20;
		int expectedSum = 30;
		
		try {
			int actualSum = calculator.add(a, b);
			if(expectedSum == actualSum) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
	}
	
	void testAddWithNegativeNumbers() {
		Calculator calculator = new Calculator();
		int a = -10;
		int b = -20;
		int expectedSum = -30;
		
		try {
			int actualSum = calculator.add(a, b);
			if(expectedSum == actualSum) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
	}
	
	void testSubstractWithPostiveNumbers() {
		Calculator calculator = new Calculator();
		int a = 10;
		int b = 20;

		try {
			int expectedSubs = 10;
			int actualSubs = calculator.substract(b, a);
			if(expectedSubs == actualSubs) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
	}
	
	void testSubstractWithNegativeNumbers() {
		Calculator calculator = new Calculator();
		int a = -10;
		int b = -20;

		try {
			int expectedSubs = -30;
			int actualSubs = calculator.substract(b, a);
			if(expectedSubs == actualSubs) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
	}
	
	public static void main(String args) {
		CalculatorTest calcuatorTest = new CalculatorTest();
		calcuatorTest.testAddWithPositiveNumbers();
		calcuatorTest.testAddWithNegativeNumbers();
		calcuatorTest.testSubstractWithPositiveNumbers();
		calcuatorTest.testSubstractWithNegativeNumbers();
	}
}	

package pkg2;
public class CircleTest {
	void testAreaWithPositiveNumber() {
		Circle circle =new Circle();
		int r = 2;
		float expectedArea = 12.56;
		
		try {
			float actualArea = circle.area(r);
			if(expectedArea == actualArea) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
	}
	
	void testPerimeterWithPositiveNumber() {
		try {
			float expectedPerimeter = 12.56;
			float actualPerimeter = circle.perimeter(r);
			if(expectedPerimeter == actualPerimeter) {
				sop(".");
			}else {
				sop("f");
			}
		}catch(Throwable t) {
			sop("e");
		}
	}
	
	public static void main(String[] args) {
		CircleTest ct = new CircleTest();
		ct.testAreaWithPositiveNumber();
		ct.testPerimeterWithPositiveNumber();
	}
}
	
	
In the above code, we have per each testcase class a main() method, which should be run for performing unit testing. So to perform testing for all the components of our application we need to run each testcase class individually, which is going to be quite annoying.
	
instead let us have one single class, that takes the responsibility of running all the testcase classes and their methods in our application which is called "TestRunner".
	
class TestResult {
	int totalTests;
	int totalSuccess;
	int totalFailures;
	int totalErrors;
	
	public TestResult() {
		totalTests = 0;
		totalSuccess = 0;
		totalFailures = 0;
		totalError = 0;
	}
	
	void sucess() {
		totalTests++;
		totalSuccess++;
	}
	void failed() {
		totalTests++;
		totalFailures++;
	}
	void error() {
		totalTests++;
		totalErrors++;
	}
}
	
package test;
class TestRunner {
	public static void main(String[] args) {
		TestResult result = new TestResult();
		
		CalculatorTest calcuatorTest = new CalculatorTest();
		try {
			calculatorTest.setup();
			calcuatorTest.testAddWithPositiveNumbers();	
			calculatorTest.tearDown();
			result.success();
		}catch(AssertionFailedException e) {
			sop("f");
			e.printStackTrace();
			result.failed();
		}catch(Throwable t) {
			sop("e");
			e.printStackTrace();
			result.error();
		}
		
		try {
			calculatorTest.setup();
			calcuatorTest.testAddWithNegativeNumbers();
			calculatorTest.tearDown();
			result.success();
		}catch(AssertionFailedException e) {
			sop("f");
			e.printStackTrace();
			result.failed();
		}catch(Throwable t) {
			sop("e");
			e.printStackTrace();
			result.error();
		}
		
		try {
			calculatorTest.setup();
			calcuatorTest.testSubstractWithPositiveNumbers();
			calculatorTest.tearDown();
			result.success();
		}catch(AssertionFailedException e) {
			sop("f");
			e.printStackTrace();
			result.failed();
		}catch(Throwable t) {
			sop("e");
			e.printStackTrace();
			result.error();
		}
		
		try {
			calculatorTest.setup();
			calcuatorTest.testSubstractWithNegativeNumbers();	
			calculatorTest.tearDown();
			result.success();
		}catch(AssertionFailedException e) {
			sop("f");
			e.printStackTrace();
			result.failed();
		}catch(Throwable t) {
			sop("e");
			e.printStackTrace();
			result.error();
		}
		
		
		CircleTest ct = new CircleTest();
		try {
			ct.setup();
			ct.testAreaWithPositiveNumber();	
			ct.tearDown();
			result.success();
		}catch(AssertionFailedException e) {
			sop("f");
			e.printStackTrace();
			result.failed();
		}catch(Throwable t) {
			sop("e");
			e.printStackTrace();
			result.error();
		}
		
		try {
			ct.setup();
			ct.testPerimeterWithPositiveNumber();	
			ct.tearDown();
			result.success();
		}catch(AssertionFailedException e) {
			sop("f");
			e.printStackTrace();
			result.failed();
		}catch(Throwable t) {
			sop("e");
			e.printStackTrace();
			result.error();
		}
		sop("total runs : " +result.getTotalTests() + ", success: "+ result.getSuccess() + ", failed :" + result.getFailures() + ", errors: "+ results.getErrors())
	}
}	
	
further we can optimize this code, by removing the try/catch in each test method and write in Test runner as shown below

class CalculatorTest {
	Caculator calculator;
	
	void setup() {
		calculator = new Calculator();	
	}
	
	void testAddWithPositiveNumbers() {	
		int a = 10;
		int b = 20;
		int expectedSum = 30;
		
		int actualSum = calculator.add(a, b);
		Assert.assertEquals(expectedSum, actualSum);
	}
	
	void testAddWithNegativeNumbers() {
		int a = -10;
		int b = -20;
		int expectedSum = -30;
		
		int actualSum = calculator.add(a, b);
		Assert.assertEquals(expectedSum, actualSum);
	}
	
	void testSubstractWithPostiveNumbers() {
		int a = 10;
		int b = 20;

		int expectedSubs = 10;
		int actualSubs = calculator.substract(b, a);
		Assert.assertEquals(expectedSubs, actualSubs);
		
	}
	
	void testSubstractWithNegativeNumbers() {
		int a = -10;
		int b = -20;

		int expectedSubs = -30;
		int actualSubs = calculator.substract(b, a);
		Assert.assertEquals(expectedSubs, actualSubs);
	}
	
	void tearDown() {
		calculator = null;
	}
}
	
package pkg2;
public class CircleTest {
	Circle circle;
	
	void setup() {
		circle = new Circle();
	}
	
	void testAreaWithPositiveNumber() {
		int r = 2;
		float expectedArea = 12.56;
				
		float actualArea = circle.area(r);
		Assert.assertEquals(expectedArea, actualArea);
	}
	
	void testPerimeterWithPositiveNumber() {
		float expectedPerimeter = 12.56;
		float actualPerimeter = circle.perimeter(r);
		Assert.assertEquals(expectedPerimeter, actualPerimeter);
	}
	void tearDown() {
		ct = null;
	}
}
	

class AssertionFailedException extends Exception {
	Object expected;
	Object actual;
	public AssertionFailedException(Object expected, Object actual) {}
}
	
	
class Assert {
	static void assertEquals(int expected, int actual) {
		if(expected == actual) {
			return;
		}else {
			throw new AssertFailedException(expected, actual);
		}
	}
	
	static void assertEquals(float expected, float actual) {
		if(expected == actual) {
			return;
		}else {
			throw new AssertFailedException(expected, actual);
		}
	}
	
	static void assertTrue(boolean actual) {
		if(actual == false) {
			throw new AssertFailedException(true, actual);
		}
	}
}	
	
	
	
Instead of writing the TestRunner with logic for invoking all the testcase methods of all the classes, we can enforce standard conventions in writing the methods in the TestCase class and invoke them dynamically using reflection as below.
Fixture Initialization = setup() {}
cleanup                = tearDown() {}
each testcase method must and should start with = testXXX() {}

defining these standard methods we can have a base class as TestCase
class TestCase {
	protected void setUp() {}
	protected void tearDown() {}
}

class CalculatorTest extends TestCase {
	Calculator calculator;
	int a;
	int b;
	int expectedSum;
	
	public void setUp() {
		calculator = new Calculator();
		a = 10;
		b = 20;
		expectedSum = 30;
	}
	
	public void tearDown() {
		calculator = null;
		a = 0;
		b = 0;
		expectedSum = 0;
	}
	
	public void testAddWithPositive() {
		int actualSum = calculator.add(a , b);
		Assert.assertEquals(expectedSum, actualSum);
	}
}

java TestRunner pkg1.CalculatorTest pkg2.CircleTest

class TestRunner {
	public static void main(String[] testCaseClasses) {
		TestResult result = new TestResult();
		Stream.of(testCaseClasses).forEach(testCaseClass-> {
		
			Class clazz = Class.forName(testCaseClass);
			Method[] methods = clazz.getDeclaredMethods();
			
			for(Method method : methods) {
				try {
					if(method.getName().startsWith("test")) {
						Object testCaseClassObject = clazz.newInstance();
						((TestCase)testCaseClassObject).setUp();
						method.invoke(testCaseClassObject, new Object[]{});
						((TestCase)testCaseClassObject).tearDown();					
					}
					result.success();
				}catch(AssertionFailedException e) {
					result.failed();
				}catch(Throwable t) {
					result.error();
				}
			}
		});	
		sop("total runs : " +result.getTotalTests() + ", success: "+ result.getSuccess() + ", failed :" + result.getFailures() + ", errors: "+ results.getErrors())
	}
}

From the above code we have implemented we can derive the typical requirements in writing the unittest automation code for an application as below:
1. each test that we perform should produce the end outcome as pass/fail
2. there should be a way to initialize the test fixtures and destroy while executing each test we conduct.
3. every test method should be executed in an isolated way from another test method and a failure in conducting the test should not impact other test executions
4. each test failure should be reported via an exception rather than an outcome
5. need a proper reporting indicating how tests are conducted, how many failed, passed and errored
6. require to centralize the testcase execution logic using TestRunners, the TestRunners should be designed to dynamically identify the test methods of the Test classes in executing them.
	
looks like everyone across all the projects needs to take care of addressing the above aspects/requirements in implementing the unittest automation code aspart of their applications. as it is a common requirement for everyone who implements unittesting automation, instead of we writing we need to make use of unittest automation frameworks like JUnit, TestNG etc.
	
JUnit
The JUnit is an unit test automation framework that has provided lot of api classes, allowing developers to quickly write testcases, the JUnit engine takes case of executing the testcases written by us and reports the statistics out of conducting the testing.
it has provided most of the api classes like
1. Asserts
2. Exceptions for reporting failures
3. TestRunners
4. TestResult classes for capturing the test execution statistics
etc

The programmer has to only write the TestCase class with test methods in conducting the testing of the original class and their methods and pass them as an input to JUnit TestRunners for execution

There are 3 versions of JUnit is available 
1. JUnit3
2. JUnit4
3. JUnit5.x

JUnit3
JUnit3 is the initial releases of JUnit Framework and currently not being actively used in the market. In the later versions of JUnit there are lot of features/improvements are added, let us understand one example on how to implement testcases using JUnit3

junit3demo
|-src
	|-com.ju3.beans
		|-Calculator.java
|-testsrc
	|-com.jun3.beans
		|-CalculatorTest.java
|-bin
	|-com.ju3.beans
		|-Calculator.class
|-testbin
	|-com.ju3.beans
		|-CalculatorTest.class
|-lib
	|-junit3.jar
	|-hamcrest.jar

testsrc/
package com.jun3.beans;
public class CalculatorTest extends TestCase {
	Calculator calculator;
	int a;
	int b;
	int exepctedSum;
	
	public void setUp() {
		calculator = new Calculator();
		a = 10;
		b = 20;
		expectedSum= 30;
	}
	
	void testAddWithPositiveNumbers() {
		int actualSum = calculator.add(a, b);
		Assert.assertEquals(expectedSum, actualSum);
	}
	
	public void tearDown() {
		calculator = null;
		a = 0;
		b = 0;
		expectedSum = 0;
	}
}

JUnit3 has provided a TestRunner class called "junit.textui.TestRunner", which is an console-based runner that produces the textual output of the test executions. 
To this class we need to pass the fqn of the TestCase classes, so that it searches for testmethods that starts with testXXX() and executes them along with test fixture methods which are setUp() and tearDown(), reports the TestResults after completion








	






































































	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	







































































































