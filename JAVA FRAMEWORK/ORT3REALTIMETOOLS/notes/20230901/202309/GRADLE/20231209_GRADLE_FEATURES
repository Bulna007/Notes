
Features of Gradle:
1. High Performance
1.1 Gradle builds are incremental, it checks the timestamp of the sourcefiles from the previous build and if there is a change in the timestamp then it recompiles otherwise ignores which will improves significantly the build execution time of a project
1.2 all the dependencies that are configured in the gradle buildfile are downloaded in-parallel from the repositories, this will greatly improves the performance and reduces the build time
1.3 we can enable build cache, which will reuses the output of task in subsequent task runs, given if the output of the task execution is not going to change

2. JVM Foundation
Gradle runs on JVM, so we should have jvm being installed on the machine to use gradle, as it runs on jvm, we get platform portability

3. Conventions
In Maven, it eliminates writing buildscript file by imposing conventions and standard build lifecycle. The Gradle also takes the concept of conventions from Maven. So for most of java projects can be build with default conventions. So, gradle has provided plugins for each type of project, these plugins are defined with tasks and conventions that are imported into our project using which we can build the project easily eliminating the need of writing buildscript file.
	
4. Extensibility
Extensibility can be achieved easily in gradle by writing our own Tasks or Plugins to enhance the build

5. Debugging
Build scan provides extensive information about the build run, so we can easily determine the build failures
---------------------------------------------------------------------------------------------------------------------------------------------
Working with Tasks in gradle
Every Task in gradle has 2 action blocks
1. doFirst
2. doLast

We can write the code inside the Task either in doFirst{} clouser or doLast {} clouser. A clouser is nothing but a block of code wrapped in a annonymous object. This block of code can be assigned to an variable or even can be passed as parameter to a method. A Clouser is equal to an lamdba expression in java8. 
	
The name itself tells you doFirst will perform execution first, at the end of the execution of the task, the doLast will be executed.

shortend form of writing the doFirst and doLast is:
task taskName {
	doFirst {
		
	}
	doLast {
		
	}
}
(or)
task taskName {
	<< {
		
	}
	>> {
		
	}
}


We can run "gradle tasks" that displays all the available tasks of a project. By default our own custom tasks will not be shown or displayed because gradle treats all the ungrouped tasks as private and will not be displayed.
	
By default all the tasks are public, if those are not belonging to null group. So to display our tasks in gradle, we need to add our task to a group as below.
	
task "taskName" {
	doFirst {}
	doLast {}
}
taskName.group="group"
	
now if we run gradle tasks, we should see our tasks in the list of tasks under the group we defined.
--------------------------------------------------------------------------------------------------------------------------------------------
From Gradle 7, the task definitions has been changed.
Representing an Gradle project, the gradle creates an Project object in which it keeps all the tasks as collection. We can define and register our tasks into the task collection using a method called "register".
	
in a gradle build file, the project is an implicit object
	
There are multiple ways we can define a task in gradle 7
#1. register a task and define it

tasks.register("taskName") {
	doFirst {}
	doLast {}
}

for eg..
tasks.register("build") {
	doFirst {}
	doLast {}
}

#2. register a task and define the body of the task latter, using the task name as below
tasks.register("taskName") // we just registered without defining the body of the task

tasks.named("taskName") {
	doFirst {}
	doLast {}
}

#3. A task can be registered and configured later, so while executing a task Gradle reads task definitions, applies the configurations and executes it

def copTask = tasks.register("copy") {
	ext.source = ""
	doFirst {
		println "copying ${source} into the destination folder"
	}
}


copyTask.configure {
	source = "~/projects"
}

#4. task group and description
tasks.register("taskName") {
	group="groupName"
	description="description"
	doLast {
	
	}
}


---------------------------------------------------------------------------------------------------------------------------------------------
How to declare variables in Task?
We can declare variables in Gradle at 2 levels

1. project level = global variables which can be reused across the project
2. task level = extra properties defined and is accessible within the scope of the task only

build.gradle
------------
// project level variables
def variableName="value"
def variableName="value"

tasks.register("taskName") {
	ext {
		variableName = "value"
	}
	doLast {
		
	}
}
---------------------------------------------------------------------------------------------------------------------------------------------
Working with Task dependencies
There are several tasks that needs to be executed in a specific order inorder to build the project in gradle. memorizing them and executing them in that order is very complex, so while declaring the tasks itself we can express or configure dependencies between them, based on the order of their execution

There are 2 ways we can declare dependencies between the tasks
1. while declaring the tasks itself we can define the dependency
2. define the task and configure dependencies later

#1. while declaring the task itself we can define dependencies as below
tasks.register("clean") {
	doLast {
		println "cleaning the project target/ directories"
	}
}

tasks.register("createdirs") {
	dependsOn tasks.clean
	doLast {
		println "creating target/ directories"
	}
}
Now we can launch the build using: gradle createdirs

	
#2. define the task and configure dependencies later
tasks.register("clean") {
	doLast {
		println "cleaning"
	}
}

def createDirsTask = tasks.register("createdirs") {
	doLast {
		println "creating directories"
	}
}
	

createDirsTask.configure {
	dependsOn tasks.clean
}

How to declare a default task in gradle build?
while launching the gradle build, the developer has to always specify the taskName to be executed, it is hard to memorize the taskName in launching the build, instead we can declare defaultTask which will be by default executed when the user has not supplied any taskName while launching the build. We can always override the defaultTask by explicitly passing the taskName

build.gradle
-------------
defaultTasks 'task1'
tasks.register("task1") {
	
}

tasks.register("task2") {
	
}

How to enable or disable a Task?
def task = tasks.register("taskName") {
	doLast {}
}	

task.configure {
	enabled = false
}


Conditional Tasks
We can bind conditions based on which the tasks can be executed.
def compileTask = tasks.register("compile") {
	doLast {
		println "compiling the project"
	}
}	

compileTask.configure {
	onlyIf {
		project.hasProperty("javaVersion") && project.javaVersion=="11"
	}	
}

gradle -PjavaVersion=9 compile
as we are passing the property as 9, the compile task will be ignored













































	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
























































































	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


















	

























































