structure of maven web application project?

project (directory)
|-src
  |-main
		|-java
		|-resources
		|-webapp   (public directory)
			|-WEB-INF (protected directory)
				|-web.xml
|-target
	|-classes
|-pom.xml

public directory = all the resources that are placed inside the public directory are accessible directly by the client
protected directory = all the resources that are placed inside the protected directory (/WEB-INF) including its subdirectories are not directly accessible to the client using the resource name
all the java classes or .class files of our application should not be downloadable to the enduser as an resource, so protected these classes of our application and not to allow the clients to directly access them we place all the .class files of the project under /WEB-INF/classes directory. Similarly the jar files (dependencies) of our application also placed under /WEB-INF/lib directory.
	
upon sending the request to the servlet container, for accessing these classes, the servlet container executes the corresponding java class and the output generated by these classes will dispatched as response to the client
	
when we package an web application, it would be packaged into an .war file structure.
	
.war (webroot)
|-public resources
|-images
|-fonts
|-css
|-js
|-icons
|-*.jsp
|-WEB-INF
	|-classes
	|-lib
	|-web.xml

the war file will be deployed into the servlet container by placing it into the deployment directory of the server.
--------------------------------------------------------------------------------------------------------------------------------------
In a spring web mvc application, it is not recommended to place the views (jsp/html) directly under the webapp directory, why?
1. there are few views/jsp pages, that renders the data as an result out of processing the request, which are called dynamic views. if such pages/views are placed under the webapp directory, those will become directly access to the enduser, that results in an ugly error pages due to the in-availability of the data
2. to abstract or hide the presentation tier view technology from the enduser, it is recommended to place the views inside the protected directory only


1. how to configure the DispatcherServlet within our application?
	
web.xml
-------
<servlet>
	<servlet-name>dispatcher</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
	<servlet-name>dispatcher</servlet-name>
	<url-pattern>*.htm</url-pattern>
</servlet-mapping>



where do we need to place the views in spring mvc application?
in spring webmvc application it is recommended to place the views under the /WEB-INF/ directoy
1. to hide/abstract the presentation-tier view technology from the enduser
2. to avoid directly accessing the dynamic views by the enduser

the other internal resources/components of our application can only access the resources that are placed in protected directory of our application.
	
web.xml
<servlet>
	<servlet-name>dispatcher</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
	<servlet-name>dispatcher</servlet-name>
	<url-pattern>*.htm</url-pattern>
</servlet-mapping>


load-on-startup = will let the servlet container instantiate the object of the servlet during the time of deployment of the application itself.
		
How does dispatcher servlet creates the ioc container?
1. during the time of deploying the application, since we configured load-on-startup=1, the servlet container will instantiates the object of the DispatcherServlet	and will call init() method on it to initialize

2. within the init() method of the DispatcherServlet, it looks for the servlet-name with which the DispatcherServlet has been configured.
		
void init(ServletConfig config) {
		String servletName = config.getServletName();
}
picks the name and appends -servlet.xml and looks for the file under /WEB-INF directory project
/WEB-INF/dispatcher-servlet.xml (spring bean configuration file)
	
if this file is not found, it throws an exception and stops the deployment of the application.
if the file is found, the DispatcherServlet reads the spring bean configuration, using which it creates an ioc container and holds the reference of it, so that it can lookup for HandlerMapping, Controllers, ViewResolver and Views etc for processing the request.
--------------------------------------------------------------------------------------------------------------------------------------
2. How to write the Controller?
	
Since the DispatcherServlet has to invoke the Controller class and its method to process the request, it should be written based on the standard interface/class provided by spring framework
	
interface Controller {
	ModelAndView handleRequest(HttpServletRequest, HttpServletResponse);
}	
to write a Controller class, we need to must and should implement our class from Controller interface and override handleRequest() method in which we need to write request processing logic, so that dispatcher servlet can invoke our Controller class method.
	
	
class ViewHomeController implements Controller {
	public ModelAndView handleRequest(HttpServletRequest httpReq, HttpServletResponse httpResp) {
		ModelAndView mav = new ModelAndView();
		mav.setViewName("home");
		return mav;
	}
}	

/WEB-INF/dispatcher-servlet.xml:
<bean id="viewHomeController" class="ViewHomeController"/>
--------------------------------------------------------------------------------------------------------------------------------------
3. HandlerMapping
HandlerMapping is used for mapping an request to the appropriate controller class, that should be used for processing the request. For which request, what is the relevant Controller to be used is knows to the developer. So, its the responsibility of the developer to provide this information to the HandlerMapping, so that it return an appropriate Controller to the DispatcherServlet when requested.
	
spring has provided an standard interface using which we need to write the HandlerMapping class
	
interface HandlerMapping {
	HandlerExecutionChain getHandler(HttpServletRequest);
}
we need to write our own HandlerMapping class by implementing from HandlerMapping interface in which we need to look at the request and return the appropriate Controller to be used.
	
Instead of we writing our own HandlerMapping implementation class, spring has provided few Concreate implementations that can be used by everyone for most of the requirements. one such implementation class spring has provided is
SimpleUrlHandlerMapping = by name itself we can understand using this handler mapping we can map a request url to controller class
	
SimpleUrlHandlerMapping = has an property of Properties type called "mappings" into which we need to manually populate key as: url -> value as controller beanname that should be used for processing the request

<bean id="handlerMapping" class="SimpleUrlHandlerMapping">
	<property name="mappings">
		<props>
			<prop key="/home.htm">viewHomeController</prop>
		</props>
	</property>
</bean>

-------------------------------------------------------------------------------------------------------------------------------------
4. How to write an View class to render an jsp page
View: in spring mvc an view can be anything and is expressed interms of an abstract component called View interface. We can write our own implementations of the View interface in which we can write the logic for rendering anyType of view to the enduser.

spring has provided an standard interface called "View"
interface View {
	void render(httpReq, httpResp, Map<String, Object> model);
}

Now to render an home.jsp page we can write our own implementation class for the View interface in which we need to write the logic for rendering it.
	
class HomeView implements View {
	public void render(HttpServletRequest httpReq, HttpServletResponse httpResp, Map<String, Object> model) {
		if(model != null && model.size()>0) {
			model.forEach((k,v)->{
				httpReq.setAttribute(k, v);
			});			
		}
		httpReq.getRequestDispatcher("/home.jsp").forward(httpReq, httpResp);
	}
}	

class IndexView implements View {
	public void render(HttpServletRequest httpReq, HttpServletResponse httpResp, Map<String, Object> model) {
		if(model != null && model.size() > 0) {
			model.forEach((k,v)->{
				httpReq.setAttribute(k, v);
			});	
		}
		httpReq.getRequestDispatcher("/index.jsp").forward(httpReq, httpResp);
	}
}

// generic class
class JspViewImpl implements View {
	private String viewName;
	
	public JspViewImpl(String viewName) {
		this.viewName = viewName;
	}
	
	public void render(HttpServletRequest httpReq, HttpServletResponse httpResp, Map<String, Object> model) {
		if(model != null && model.size() > 0) {
			model.forEach((k,v)->{
				httpReq.setAttribute(k, v);
			});	
		}
		httpReq.getRequestDispatcher(viewName).forward(httpReq, httpResp);
	}
}

in every web application, we have jsp pages as views, to render them in every project we need to write an view implementation class to render anyJsp. isntead we writing our own View class to render jsp pages, the spring framework itself has provided an Concrete implementation class for View interface that can render any jsp called "JSTLView"
	
JSTLView = java standard tag library view

class JSTLView implements View {
	private String viewName;
	
	public JspViewImpl(String viewName) {
		this.viewName = viewName;
	}
	
	public void render(HttpServletRequest httpReq, HttpServletResponse httpResp, Map<String, Object> model) {
		if(model != null && model.size() > 0) {
			model.forEach((k,v)->{
				httpReq.setAttribute(k, v);
			});	
		}
		httpReq.getRequestDispatcher(viewName).forward(httpReq, httpResp);
	}
}
--------------------------------------------------------------------------------------------------------------------------------------
5: ViewResolver
ViewResolver is used for mapping an logic view name that is returned by the Controller class to an appropriate View implementation class. And it even instantiates the object of the View implementation class and returns it to the DispatcherServlet
	
The developer has to pass the configuration pertaining to which lvn should be mapped to which view to be rendered, so that ViewResolver takes the job of looking 	up for the View and instantiates and returns

Spring MVC has defined an standard interface for ViewResolver

interface ViewResolver {
	View resolve(HttpRequest, HttpResponse, Locale, String lvn) {
	
	}
}


ViewResolver
ViewResolver is an component that takes the logical viewname as an input and returns the appropriate View implementation class object that should be used for rendering an view to the user

The developer is the one who knows for which outcome (lvn) of the controller which jsp page should be rendered as an output using the View class. So this information has to be fed as an input to the ViewResolver so that it can return an appropriate View implementation class to the DispatcherServlet
	
The spring mvc has provided an standard interface from which we need to write our own ViewResolver implementation
	
interface ViewResolver {
	View resolve(String viewName, Locale locale);
}

|-contact-us
|-index
|-home
class JSTLViewResolver implements ViewResolver {
	public View resolve(String viewName, Local locale) {
		JSTLView view = null;
		
		view = new JSTLView("/WEB-INF/jsp/"+viewName+".jsp");			
		return view;
	}
}
Looks like in every web application, jsp is an common view technology and we need to write our own implementation of ViewResolver interface that takes care of instantiaing the JSTLView class object by populating the jspPage url to be rendered. Since it is an common requirement instead of we writing our own ViewResolver implementation for rendering jsp pages, Spring mvc has provided an implementation class called "InternalResourceViewResolver"
	
The InternalResourceViewResolver takes prefix & suffix 	and prepends,appends them to the logical viewname and populates it into the JSTLView implementation object and returns to the DispatcherServlet.
	
class InternalResourceViewResolver implements ViewResolver {
	private String prefix;
	private String suffix;
	
	public View resolve(String viewName, Local locale) {
		JSTLView view = null;
		
		view = new JSTLView(prefix+viewName+suffix);			
		return view;
	}
}	

Now we can directly configure InternalResourceViewResolver as an bean definition within our application.
	
<bean id="viewResolver" class="InternalResourceViewResolver">
	<property name="prefix" value="/WEB-INF/jsp/"/>
	<property name="suffix" value=".jsp"/>
</bean>































	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	







































	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
















































































	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	






















	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	