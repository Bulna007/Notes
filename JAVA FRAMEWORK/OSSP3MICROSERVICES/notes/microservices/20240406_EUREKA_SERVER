Discovery Server
----------------
The Microservices are scattered and deployed across the nodes of the cluster, where not all the nodes of the cluster are symmetric in nature. So in such case the client will not know which microservice is running on what nodes of the cluster to access. To help the clients in locating the microservices, so that he can access it we need DiscoveryServer

Eureka Server
The Eureka Server is an opensource software distribution offered by Netflix, it is built on jaxrs api (jersey implementation). There are 2 ways we can host the eureka server in our systems to be integrated with our microservices

1. we can checkout/clone their github project, modify the configurations in their sourcecode (locally). build and deploy on tomcat server or any servlet container
2. The netflix has distributed eureka as jar distribution. We can add them as dependencies into our project and expose their endpoints in our project by populating configurations into them.
	
Hosting an eureka server looks to be an laborious job because we need to
1. identify the dependent libraries of the eureka with their compatible versions to our project inorder to use their endpoints
2. along with that we need to identify the configuration options we have by looking through their documentation and attach it in our application, using which the server would be bootstrapped

Instead of we identifying, configuring and hosting by ourself, we can have eureka server quickly running by using the help of spring boot + spring cloud + spring microservices eureka integration

The spring microservices team has built integrations into Eureka server by building an spring boot starter for us. This starter dependency includes netflix-eureka library, transitives and auto configurations shipped aspart of it. The auto-configurations takes care of reading the properties from application.yaml|properties of our project using which it takes care of configuring the eureka server components inorder to host them in our application.
In addition the spring boot takes care of deploying the server on embedded servlet container. This releaves us greatly from
1. identifying transitives with their compatibilities
2. understanding the configurations we need to write, as most of the defaults are taken care by auto-configurations
3. manually package and deploy because spring boot takes care of deploying it on embedded server
so that we can quickly have eureka server hosted in our application.
	
How to use the Eureka server?
Every discovery server in order to use it, it has #3 parts of it
1. hosting or running the discovery server
2. let the microservices during their startup/bootup register themself with discovery server and publish periodically the heartbeats
3. allow the client applications to lookup/discover the services using the help of discovery server
--------------------------------------------------------------------------------------------------------------------------------
How to work with Eureka Server?
1. create an spring boot + spring cloud application with the below starter dependencies defined in pom.xml
1.1 spring-cloud-starter
1.2 spring-cloud-starter-config
1.3 spring-boot-starter
1.4 spring-cloud-eureka-server

2. There are 2 aspects we need to know about Eureka Server before launching it
The Eureka Server (spring-cloud-eureka-server) by default comes with discovery client library as transitive. The Discovery client api is usually used by microservices or client applications inorder to communicate with Eureka Server

1. Microservice application
An microservice application has to register itself during the time of bootstrapping with the EurekaServer, thereafter it has to periodicaly publish the heartbeats information to the eureka server. This functionality of registering and publishing the heartbeats are pre-built and shipped aspart of spring-cloud-discovery-client library

2. Client Applications
Client applications inorder to invoke the microservices, they need to perform a lookup or fetch operation of the registry from EurekaServer, inorder to talk to eureka server in fetching the registry, they need to use spring-cloud-discovery-client api

From the above we can understand spring-cloud-discovery api is being used both by client applications and microservices inorder to talk to eureka server

Then why does eureka server has added discovery client as an transitive?
There are 2 reasons why we need discovery client capabilities in eureka server as well.
When we are running the eureka server in production environment, for high availability we need to run atleast #2 instances of eureka server as a master/slave architecture, so that when the primary node went down, the secondary/slave acts as an primary until the primary node has been restored, so that the whole cluster will not go down.
	
1. The slave/secondary eureka server has to register itself to the primary as an replica and should send periodical heartbearts to the primary indicating its availability

2. The slave/secondary has to fetch the registery of the primary and should populate into itself

to perform these 2 functionalities the seondary eueraka server has to talk to primary acting as an client which can be done through dicovery client api/library

While launching the primary/master eureka server we need to turn off
1. register
2. fetch
capabilities
this can be done by writing below configuration in application.yml of our primary server application

application.yml
---------------
eureka:
  client:
    register-with-eureka: false
		fetch-registry: false

By reading the above #2 properties the auto-configurations takes care of configuring the eureka server endpoints appropriately

3. enable the eurekaserver endpoint by enabling the auto-configurations

@SpringBootApplication
@EnableEurekaServer
class EurekaServerApplication {}
--------------------------------------------------------------------------------------------------------------------------------
How to register microservice applications with Eureka Server?
As we bring up the Eureka Server up and running, its the time for our microservice applications register with Eureka Server during their startup and publish the heartbeats periodically with eureka server

The Netflix has provided eureka client library that has the capabilities of registering the application with eureka server and publish heartbeats, all that we have to do is just provide the URL of the EurekaServer where it has been hosted.
	
distributor-network
|-src
  |-main
	  |-java
		|-resources
		  |-application.yml
			|-bootstrap.yml
|-pom.xml
  |-spring-cloud-starter-config
	|-spring-cloud-bootstrap
  |-spring-cloud-starter-netflix-eureka-client


application.yml
----------------
server:
  port: 8081
spring:
  application:
    name: distributor-network
		
distributor-network-test.yml [Config Server]		
------------------------
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/distributorntwdb
    username: root
    password: welcome1
  jpa:
    show-sql: true
    generate-ddl: false
network:
  businessType: retailer
  locationType: local
eureka:
  client:
    register-with-eureka: true
		fetch-registry: false
		service-url:
      default-zone: http://localhost:9091/eureka
--------------------------------------------------------------------------------------------------------------------------------
How to enable HA for Eureka Server?
While hosting the Eureka Server in production environment, we should not run single-instance of the Eureka server because if it went down the whole cluster will become in-accessible causing single-point of failure.
	
To have High-availability, we need to run multiple replicas of the EurekaServer on #2 different machines, so that if one crashes the other machine will be available for discovering the services.
	
1. Master Eureka
The Master Eureka server would not register with any other eureka server within the cluster and will not fetch the registery information from any other eureka server (basically we dont need discovery-client services)
	
All the microservices registers by themself with the Master eureka server only and would publish their heartbeats with Master ignoring the Slave or secondary. Incase if the Master was down, the Microservices would start communicating with Secondary.
	
2. Slave/Secondary Eureka Server
The slave/secondary register by himself with the Master eureka server and fetch the registry information from the master

application.yml
spring:
  application:
    name: suzkieurekaserver
	config:
    activate:
      on-profile: master
server:
  port: 9091
eureka:
  client:
    register-with-eureka: false
		fetch-registry: false
  config:
    activate:
      on-profie: slave
server:
  port: 9092
eureka:
  client:
    register-with-eureka: true
		fetch-registry: true
		service-url:
      defaultZone: http://localhost:9091/eureka


java -Dspring.profiles.active=master -jar target/suzkieurekaserver.jar
java -Dspring.profiles.active=slave -jar target/suzkieurekaserver.jar

Now in the microservice applications, instead of populating the primary/master eureka populate both the URLS under defaultZone where primary as first URL and secondary as second uRL














































	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	


















































































































































	
















































































